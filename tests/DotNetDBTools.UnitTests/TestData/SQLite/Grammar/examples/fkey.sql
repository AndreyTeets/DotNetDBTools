-- ===fkey1.test===
CREATE TABLE t1(
a INTEGER PRIMARY KEY,
b INTEGER
REFERENCES t1 ON DELETE CASCADE
REFERENCES t2,
c TEXT,
FOREIGN KEY (b,c) REFERENCES t2(x,y) ON UPDATE CASCADE
);

CREATE TABLE t2(
x INTEGER PRIMARY KEY,
y TEXT
);

CREATE TABLE t3(
a INTEGER REFERENCES t2,
b INTEGER REFERENCES t1,
FOREIGN KEY (a,b) REFERENCES t2(x,y)
);

CREATE TABLE t4(a integer primary key);
CREATE TABLE t5(x references t4);
CREATE TABLE t6(x references t4);
CREATE TABLE t7(x references t4);
CREATE TABLE t8(x references t4);
CREATE TABLE t9(x references t4);
CREATE TABLE t10(x references t4);
DROP TABLE t7;
DROP TABLE t9;
DROP TABLE t5;
DROP TABLE t8;
DROP TABLE t6;
DROP TABLE t10;

CREATE TABLE t5(a PRIMARY KEY, b, c);
CREATE TABLE t6(
d REFERENCES t5,
e REFERENCES t5(c)
);
PRAGMA foreign_key_list(t6);

CREATE TABLE t7(d, e, f,
FOREIGN KEY (d, e) REFERENCES t5(a, b)
);
PRAGMA foreign_key_list(t7);

CREATE TABLE t8(d, e, f,
FOREIGN KEY (d, e) REFERENCES t5 ON DELETE CASCADE ON UPDATE SET NULL
);
PRAGMA foreign_key_list(t8);

CREATE TABLE t9(d, e, f,
FOREIGN KEY (d, e) REFERENCES t5 ON DELETE CASCADE ON UPDATE SET DEFAULT
);
PRAGMA foreign_key_list(t9);

-- ===fkey2.test===
PRAGMA foreign_keys = on;

INSERT INTO i VALUES('sqlite');
INSERT INTO j VALUES('sqlite');
DELETE FROM i WHERE i = 'SQLite';

BEGIN;
DELETE FROM pp WHERE a = 2;

INSERT INTO self VALUES(13, 13);

UPDATE self SET a = 14, b = 14;

DELETE FROM self;

PRAGMA count_changes = 1;

CREATE TABLE one(a, b, c, UNIQUE(b, c));
CREATE TABLE two(d, e, f, FOREIGN KEY(e, f) REFERENCES one(b, c));
INSERT INTO one VALUES(1, 2, 3);

INSERT INTO one VALUES(2, 3, 4);
INSERT INTO one VALUES(3, 4, 5);
INSERT INTO two VALUES(1, 2, 3);
INSERT INTO two VALUES(2, 3, 4);
INSERT INTO two VALUES(3, 4, 5);

SELECT * FROM one;

SELECT * FROM two;

CREATE TABLE three(
g, h, i, 
FOREIGN KEY(h, i) REFERENCES one(b, c) DEFERRABLE INITIALLY DEFERRED
);

CREATE TABLE ab(a PRIMARY KEY, b);
CREATE TABLE cd(
c PRIMARY KEY REFERENCES ab ON UPDATE CASCADE ON DELETE CASCADE, 
d
);
CREATE TABLE ef(
e REFERENCES cd ON UPDATE CASCADE, 
f, CHECK (e!=5)
);

CREATE TABLE high("a'b!" PRIMARY KEY, b);
CREATE TABLE low(
c, 
"d&6" REFERENCES high ON UPDATE CASCADE ON DELETE CASCADE
);

INSERT INTO high VALUES('a', 'b');
INSERT INTO low VALUES('b', 'a');

UPDATE high SET "a'b!" = 'c';

SELECT * FROM high ; SELECT * FROM low;

DELETE FROM high;

SELECT * FROM high ; SELECT * FROM low;

PRAGMA count_changes = 0;

CREATE TABLE long(a, b PRIMARY KEY, c);
CREATE TABLE short(d, e, f REFERENCES long);
CREATE TABLE mid(g, h, i REFERENCES long DEFERRABLE INITIALLY DEFERRED);

INSERT INTO long VALUES(1, 2, 3);

INSERT INTO short VALUES(1, 3, 2);

INSERT INTO ab VALUES(1, 'b');
INSERT INTO cd VALUES(1, 'd');
INSERT INTO ef VALUES(1, 'e');

INSERT INTO mid VALUES(1, 3, 2);

CREATE TABLE nought(a, b PRIMARY KEY, c);
CREATE TABLE cross(d, e, f,
FOREIGN KEY(e) REFERENCES nought(b) ON UPDATE CASCADE
);

INSERT INTO nought VALUES(2, 1, 2);

INSERT INTO cross VALUES(0, 1, 0);

UPDATE nought SET b = 5;

SELECT * FROM cross;

CREATE TABLE one(a INTEGER PRIMARY KEY, b);
CREATE TABLE two(b, c REFERENCES one);
INSERT INTO one VALUES(101, 102);

INSERT INTO two VALUES(100, 101);

INSERT INTO short VALUES(1, 3, NULL);

SELECT * FROM short;

SELECT * FROM ab;

CREATE TABLE main(id INTEGER PRIMARY KEY);
CREATE TABLE sub(id INT REFERENCES main(id));
INSERT INTO main VALUES(1);
INSERT INTO main VALUES(2);
INSERT INTO sub VALUES(2);

CREATE TABLE pp(a PRIMARY KEY, b);
CREATE TABLE cc(c PRIMARY KEY, d REFERENCES pp);

SELECT * FROM cc;

BEGIN;
INSERT INTO pp VALUES(2, 'two');
INSERT INTO cc VALUES(1, 2);

COMMIT ; SELECT * FROM cc;

DELETE FROM cc ; DELETE FROM pp;

INSERT INTO pp VALUES(2, 'two');
INSERT INTO cc VALUES(1, 2);

SELECT * FROM pp;

SELECT * FROM cc;

BEGIN;
INSERT INTO pp VALUES(3, 'three');

SELECT * FROM ab; SELECT * FROM cd; SELECT * FROM ef;

COMMIT ; SELECT * FROM pp;

BEGIN;
INSERT INTO cc VALUES(2, 2);

COMMIT ; SELECT * FROM cc;

DELETE FROM cc ; DELETE FROM pp;

CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c, UNIQUE(b, c));
CREATE TABLE t2(e REFERENCES t1, f);
CREATE TABLE t3(g, h, i, FOREIGN KEY (h, i) REFERENCES t1(b, c));

INSERT INTO t1 VALUES(1, 2, 3);
INSERT INTO t2 VALUES(1, 2);

INSERT INTO t2 VALUES(NULL, 3);

UPDATE t2 SET e = 1 WHERE e IS NULL;

UPDATE t2 SET e = NULL WHERE f = 3;

UPDATE t2 SET e = NULL;

SELECT * FROM ab; SELECT * FROM cd; SELECT * FROM ef;

UPDATE t1 SET a = 10;
DELETE FROM t1;
DELETE FROM t2;

INSERT INTO t3 VALUES(1, NULL, NULL);
INSERT INTO t3 VALUES(1, 2, NULL);
INSERT INTO t3 VALUES(1, NULL, 3);

INSERT INTO t1 VALUES(1, 1, 4);
INSERT INTO t3 VALUES(3, 1, 4);

UPDATE t1 SET a = 10;

CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c, UNIQUE(b, c));
CREATE TABLE t2(e REFERENCES t1 ON UPDATE CASCADE ON DELETE CASCADE, f);
CREATE TABLE t3(g, h, i, 
FOREIGN KEY (h, i) 
REFERENCES t1(b, c) ON UPDATE CASCADE ON DELETE CASCADE
);

INSERT INTO t1 VALUES(1, 2, 3);
INSERT INTO t1 VALUES(4, 5, 6);
INSERT INTO t2 VALUES(1, 'one');
INSERT INTO t2 VALUES(4, 'four');

UPDATE t1 SET a = 2 WHERE a = 1;
SELECT * FROM t2;

DELETE FROM t1 WHERE a = 4;
SELECT * FROM t2;

INSERT INTO t3 VALUES('hello', 2, 3);
UPDATE t1 SET c = 2;
SELECT * FROM t3;

DELETE FROM t1;
SELECT * FROM t3;

CREATE TABLE t1(
node PRIMARY KEY, 
parent REFERENCES t1 ON DELETE CASCADE
);
CREATE TABLE t2(node PRIMARY KEY, parent);
CREATE TRIGGER t2t AFTER DELETE ON t2 BEGIN
DELETE FROM t2 WHERE parent = old.node;
END;
INSERT INTO t1 VALUES(1, NULL);
INSERT INTO t1 VALUES(2, 1);
INSERT INTO t1 VALUES(3, 1);
INSERT INTO t1 VALUES(4, 2);
INSERT INTO t1 VALUES(5, 2);
INSERT INTO t1 VALUES(6, 3);
INSERT INTO t1 VALUES(7, 3);
INSERT INTO t2 SELECT * FROM t1;

CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c, UNIQUE(c, b));
CREATE TABLE t2(e REFERENCES t1 ON UPDATE SET NULL ON DELETE SET NULL, f);
CREATE TABLE t3(g, h, i, 
FOREIGN KEY (h, i) 
REFERENCES t1(b, c) ON UPDATE SET NULL ON DELETE SET NULL
);

INSERT INTO t1 VALUES(1, 2, 3);
INSERT INTO t1 VALUES(4, 5, 6);
INSERT INTO t2 VALUES(1, 'one');
INSERT INTO t2 VALUES(4, 'four');

UPDATE t1 SET a = 2 WHERE a = 1;
SELECT * FROM t2;

DELETE FROM t1 WHERE a = 4;
SELECT * FROM t2;

INSERT INTO t3 VALUES('hello', 2, 3);
UPDATE t1 SET c = 2;
SELECT * FROM t3;

UPDATE t3 SET h = 2, i = 2;
DELETE FROM t1;
SELECT * FROM t3;

PRAGMA foreign_keys=ON;
CREATE TABLE tdd08(a INTEGER PRIMARY KEY, b);
CREATE UNIQUE INDEX idd08 ON tdd08(a,b);
INSERT INTO tdd08 VALUES(200,300);
CREATE TABLE tdd08_b(w,x,y, FOREIGN KEY(x,y) REFERENCES tdd08(a,b));
INSERT INTO tdd08_b VALUES(100,200,300);

SELECT * FROM tdd08;

CREATE TABLE tce71(a INTEGER PRIMARY KEY, b);
CREATE UNIQUE INDEX ice71 ON tce71(a,b);
INSERT INTO tce71 VALUES(100,200);
CREATE TABLE tce72(w, x, y, FOREIGN KEY(x,y) REFERENCES tce71(a,b));
INSERT INTO tce72 VALUES(300,100,200);
UPDATE tce71 set b = 200 where a = 100;
SELECT * FROM tce71, tce72;

CREATE TABLE tce73(a INTEGER PRIMARY KEY, b, UNIQUE(a,b));
INSERT INTO tce73 VALUES(100,200);
CREATE TABLE tce74(w, x, y, FOREIGN KEY(x,y) REFERENCES tce73(a,b));
INSERT INTO tce74 VALUES(300,100,200);
UPDATE tce73 set b = 200 where a = 100;
SELECT * FROM tce73, tce74;

PRAGMA recursive_triggers = off;

BEGIN;
DELETE FROM t1 WHERE node = 1;
SELECT node FROM t1;

DELETE FROM t2 WHERE node = 1;
SELECT node FROM t2;
ROLLBACK;

PRAGMA count_changes = 1;

PRAGMA recursive_triggers = on;

BEGIN;
DELETE FROM t1 WHERE node = 1;
SELECT node FROM t1;

DELETE FROM t2 WHERE node = 1;
SELECT node FROM t2;
ROLLBACK;

CREATE TABLE t1(a PRIMARY KEY, b);
CREATE TABLE t2(a PRIMARY KEY, b REFERENCES t1(a));
INSERT INTO t1 VALUES('hello', 'world');
INSERT INTO t2 VALUES('key', 'hello');

PRAGMA foreign_keys = off;

PRAGMA foreign_keys = on;

CREATE TABLE t1(a REFERENCES t2(c), b);
CREATE TABLE t2(c UNIQUE, b);
INSERT INTO t2 VALUES(1, 2);
INSERT INTO t1 VALUES(1, 2);
VACUUM;

CREATE TABLE t1(a PRIMARY KEY, b);
CREATE TABLE t2(c INTEGER PRIMARY KEY REFERENCES t1, b);

INSERT INTO t1 VALUES(1, 2);
INSERT INTO t1 VALUES(2, 3);
INSERT INTO t2 VALUES(1, 'A');

UPDATE t2 SET c = 2;

PRAGMA count_changes = 0;

DELETE FROM t1 WHERE a = 1;

CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
CREATE TABLE t2(
c INTEGER PRIMARY KEY,
d INTEGER DEFAULT 1 REFERENCES t1 ON DELETE SET DEFAULT
);
DELETE FROM t1;

INSERT INTO t1 VALUES(1, 'one');
INSERT INTO t1 VALUES(2, 'two');
INSERT INTO t2 VALUES(1, 2);
SELECT * FROM t2;
DELETE FROM t1 WHERE a = 2;
SELECT * FROM t2;

INSERT INTO t1 VALUES(2, 'two');
UPDATE t2 SET d = 2;
DELETE FROM t1 WHERE a = 1;
SELECT * FROM t2;

SELECT * FROM t1;

CREATE TABLE pp(a, b, c, PRIMARY KEY(b, c));
CREATE TABLE cc(d DEFAULT 3, e DEFAULT 1, f DEFAULT 2,
FOREIGN KEY(f, d) REFERENCES pp 
ON UPDATE SET DEFAULT 
ON DELETE SET NULL
);
INSERT INTO pp VALUES(1, 2, 3);
INSERT INTO pp VALUES(4, 5, 6);
INSERT INTO pp VALUES(7, 8, 9);

INSERT INTO cc VALUES(6, 'A', 5);
INSERT INTO cc VALUES(6, 'B', 5);
INSERT INTO cc VALUES(9, 'A', 8);
INSERT INTO cc VALUES(9, 'B', 8);
UPDATE pp SET b = 1 WHERE a = 7;
SELECT * FROM cc;

DELETE FROM pp WHERE a = 4;
SELECT * FROM cc;

CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
CREATE TABLE t2(c, d, FOREIGN KEY(c) REFERENCES t1(a) ON UPDATE CASCADE);
INSERT INTO t1 VALUES(10, 100);
INSERT INTO t2 VALUES(10, 100);
UPDATE t1 SET a = 15;
SELECT * FROM t2;

CREATE TABLE t1(a, b PRIMARY KEY);
CREATE TABLE t2(
x REFERENCES t1 ON UPDATE RESTRICT DEFERRABLE INITIALLY DEFERRED 
);
INSERT INTO t1 VALUES(1, 'one');
INSERT INTO t1 VALUES(2, 'two');
INSERT INTO t1 VALUES(3, 'three');

PRAGMA count_changes = 1;

INSERT INTO t1 VALUES(2, 'two');
COMMIT;

CREATE TABLE t1(x COLLATE NOCASE PRIMARY KEY);
CREATE TRIGGER tt1 AFTER DELETE ON t1 
WHEN EXISTS ( SELECT 1 FROM t2 WHERE old.x = y )
BEGIN
INSERT INTO t1 VALUES(old.x);
END;
CREATE TABLE t2(y REFERENCES t1);
INSERT INTO t1 VALUES('A');
INSERT INTO t1 VALUES('B');
INSERT INTO t2 VALUES('a');
INSERT INTO t2 VALUES('b');
SELECT * FROM t1;
SELECT * FROM t2;

DELETE FROM t1;

SELECT * FROM t1;
SELECT * FROM t2;

DROP TABLE t2;
CREATE TABLE t2(y REFERENCES t1 ON DELETE RESTRICT);
INSERT INTO t2 VALUES('a');
INSERT INTO t2 VALUES('b');

SELECT * FROM t1;
SELECT * FROM t2;

CREATE TABLE up(
c00, c01, c02, c03, c04, c05, c06, c07, c08, c09,
c10, c11, c12, c13, c14, c15, c16, c17, c18, c19,
c20, c21, c22, c23, c24, c25, c26, c27, c28, c29,
c30, c31, c32, c33, c34, c35, c36, c37, c38, c39,
PRIMARY KEY(c34, c35)
);
CREATE TABLE down(
c00, c01, c02, c03, c04, c05, c06, c07, c08, c09,
c10, c11, c12, c13, c14, c15, c16, c17, c18, c19,
c20, c21, c22, c23, c24, c25, c26, c27, c28, c29,
c30, c31, c32, c33, c34, c35, c36, c37, c38, c39,
FOREIGN KEY(c39, c38) REFERENCES up ON UPDATE CASCADE
);

INSERT INTO up(c34, c35) VALUES('yes', 'no');
INSERT INTO down(c39, c38) VALUES('yes', 'no');
UPDATE up SET c34 = 'possibly';
SELECT c38, c39 FROM down;
DELETE FROM down;

INSERT INTO up(c34, c35) VALUES('yes', 'no');
INSERT INTO down(c39, c38) VALUES('yes', 'no');

DELETE FROM up WHERE c34 = 'possibly';
SELECT c34, c35 FROM up;
SELECT c39, c38 FROM down;

PRAGMA count_changes = 0;

CREATE TABLE pp(a UNIQUE, b, c, PRIMARY KEY(b, c));
CREATE TABLE cc(d, e, f UNIQUE, FOREIGN KEY(d, e) REFERENCES pp);
INSERT INTO pp VALUES(1, 2, 3);
INSERT INTO cc VALUES(2, 3, 1);

SELECT * FROM pp;
SELECT * FROM cc;

COMMIT;
SELECT * FROM pp;
SELECT * FROM cc;

REPLACE INTO pp(rowid, a, b, c) VALUES(1, 2, 2, 3);
SELECT rowid, * FROM pp;
SELECT * FROM cc;

REPLACE INTO pp(rowid, a, b, c) VALUES(2, 2, 2, 3);
SELECT rowid, * FROM pp;
SELECT * FROM cc;

CREATE TABLE t1(a PRIMARY KEY);
CREATE TABLE t2(a, b);

PRAGMA foreign_keys = off;
ALTER TABLE t2 ADD COLUMN h DEFAULT 'text' REFERENCES t1;
PRAGMA foreign_keys = on;
SELECT sql FROM sqlite_master WHERE name='t2';

SELECT sqlite_rename_parent(zCreate, zOld, zNew);

CREATE TABLE t1(a PRIMARY KEY, b REFERENCES t1);
CREATE TABLE t2(a PRIMARY KEY, b REFERENCES t1, c REFERENCES t2);
CREATE TABLE t3(a REFERENCES t1, b REFERENCES t2, c REFERENCES t1);

SELECT sql FROM sqlite_master WHERE type = 'table';

CREATE TABLE i(i INTEGER PRIMARY KEY);
CREATE TABLE j(j REFERENCES i);
INSERT INTO i VALUES(35);
INSERT INTO j VALUES('35.0');
SELECT j, typeof(j) FROM j;

ALTER TABLE t1 RENAME TO t4;

SELECT sql FROM sqlite_master WHERE type = 'table';

INSERT INTO t4 VALUES(1, NULL);

INSERT INTO t3 VALUES(1, NULL, 1);

CREATE TEMP TABLE t1(a PRIMARY KEY);
CREATE TEMP TABLE t2(a, b);

PRAGMA foreign_keys = off;
ALTER TABLE t2 ADD COLUMN h DEFAULT 'text' REFERENCES t1;
PRAGMA foreign_keys = on;
SELECT sql FROM sqlite_temp_master WHERE name='t2';

CREATE TEMP TABLE t1(a PRIMARY KEY, b REFERENCES t1);
CREATE TEMP TABLE t2(a PRIMARY KEY, b REFERENCES t1, c REFERENCES t2);
CREATE TEMP TABLE t3(a REFERENCES t1, b REFERENCES t2, c REFERENCES t1);

SELECT sql FROM sqlite_temp_master WHERE type = 'table';

ALTER TABLE t1 RENAME TO t4;

SELECT sql FROM sqlite_temp_master WHERE type = 'table';

CREATE TABLE i(i INT UNIQUE);
CREATE TABLE j(j REFERENCES i(i));
INSERT INTO i VALUES('35.0');
INSERT INTO j VALUES('35.0');
SELECT j, typeof(j) FROM j;
SELECT i, typeof(i) FROM i;

INSERT INTO t4 VALUES(1, NULL);

INSERT INTO t3 VALUES(1, NULL, 1);

ATTACH ':memory:' AS aux;
CREATE TABLE aux.t1(a PRIMARY KEY);
CREATE TABLE aux.t2(a, b);

PRAGMA foreign_keys = off;
ALTER TABLE t2 ADD COLUMN h DEFAULT 'text' REFERENCES t1;
PRAGMA foreign_keys = on;
SELECT sql FROM aux.sqlite_master WHERE name='t2';

CREATE TABLE aux.t1(a PRIMARY KEY, b REFERENCES t1);
CREATE TABLE aux.t2(a PRIMARY KEY, b REFERENCES t1, c REFERENCES t2);
CREATE TABLE aux.t3(a REFERENCES t1, b REFERENCES t2, c REFERENCES t1);

SELECT sql FROM aux.sqlite_master WHERE type = 'table';

ALTER TABLE t1 RENAME TO t4;

SELECT sql FROM aux.sqlite_master WHERE type = 'table';

INSERT INTO t4 VALUES(1, NULL);

INSERT INTO t3 VALUES(1, NULL, 1);

CREATE TABLE i(i TEXT COLLATE nocase PRIMARY KEY);
CREATE TABLE j(j TEXT COLLATE binary REFERENCES i(i));
INSERT INTO i VALUES('SQLite');
INSERT INTO j VALUES('sqlite');

CREATE TABLE t1(a, b REFERENCES nosuchtable);
DROP TABLE t1;

CREATE TABLE t1(a PRIMARY KEY, b);
INSERT INTO t1 VALUES('a', 1);
CREATE TABLE t2(x REFERENCES t1);
INSERT INTO t2 VALUES('a');

DELETE FROM t2;
DROP TABLE t1;

CREATE TABLE t1(x PRIMARY KEY);
INSERT INTO t1 VALUES('x');

INSERT INTO t2 VALUES('x');

DROP TABLE t2;
DROP TABLE t1;

CREATE TABLE pp(x, y, PRIMARY KEY(x, y));
CREATE TABLE cc(a, b, FOREIGN KEY(a, b) REFERENCES pp(x, z));

DROP TABLE cc;

CREATE TABLE cc(a, b, 
FOREIGN KEY(a, b) REFERENCES pp DEFERRABLE INITIALLY DEFERRED
);

INSERT INTO pp VALUES('a', 'b');
INSERT INTO cc VALUES('a', 'b');
BEGIN;
DROP TABLE pp;
CREATE TABLE pp(a, b, c, PRIMARY KEY(b, c));
INSERT INTO pp VALUES(1, 'a', 'b');
COMMIT;

CREATE TABLE i(i TEXT PRIMARY KEY);        CREATE TABLE j(j TEXT COLLATE nocase REFERENCES i(i));
INSERT INTO i VALUES('SQLite');

BEGIN;
DROP TABLE cc;
DROP TABLE pp;
COMMIT;

CREATE TABLE b1(a, b);
CREATE TABLE b2(a, b REFERENCES b1);
DROP TABLE b1;

CREATE TABLE b3(a, b REFERENCES b2 DEFERRABLE INITIALLY DEFERRED);
DROP TABLE b2;

CREATE TABLE t1(x REFERENCES v); 
CREATE VIEW v AS SELECT * FROM t1;

DROP VIEW v;

CREATE VIRTUAL TABLE v USING echo(t1);

DROP TABLE v;

CREATE TABLE pp(a PRIMARY KEY, b);
CREATE TABLE cc(x, y REFERENCES pp DEFERRABLE INITIALLY DEFERRED);
INSERT INTO pp VALUES(1, 'one');
INSERT INTO pp VALUES(2, 'two');
INSERT INTO cc VALUES('neung', 1);
INSERT INTO cc VALUES('song', 2);

BEGIN;
INSERT INTO cc VALUES('see', 4);    -- Violates deferred constraint;

DELETE FROM cc WHERE x = 'see';

-- ===fkey3.test===
PRAGMA foreign_keys=ON;
CREATE TABLE t1(x INTEGER PRIMARY KEY);
INSERT INTO t1 VALUES(100);
INSERT INTO t1 VALUES(101);
CREATE TABLE t2(y INTEGER REFERENCES t1 (x));
INSERT INTO t2 VALUES(100);
INSERT INTO t2 VALUES(101);
SELECT 1, x FROM t1;
SELECT 2, y FROM t2;

DROP TABLE t2;

DROP TABLE t1;

PRAGMA foreign_keys=ON;
CREATE TABLE t1(x INTEGER PRIMARY KEY);
INSERT INTO t1 VALUES(100);
INSERT INTO t1 VALUES(101);
CREATE TABLE t2(y INTEGER PRIMARY KEY REFERENCES t1 (x) ON UPDATE SET NULL);

INSERT INTO t2 VALUES(100);
INSERT INTO t2 VALUES(101);
SELECT 1, x FROM t1;
SELECT 2, y FROM t2;